# Lab: HTTP & Attack Surface

### 1) **O HTTP**

HTTP to **protokół klient-serwer**:

1. **Klient (np. przeglądarka)** wysyła _HTTP Request_ — linia startowa, nagłówki, body (opcjonalnie).
2. **Serwer przetwarza request** i odsyła _HTTP Response_ — status, nagłówki, body.
3. Nagłówki określają metadane: metoda (GET/POST), host, ciasteczka, cache, proxy itp.

Przykład requesta:

```
GET /example HTTP/1.1
Host: target.com
Cookie: session=abcd
```

Przykład responsa:

```
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: token=xyz;
```

### **Struktura HTTP request / response — co analizować**

#### **Request – co ma znaczenie?**

| Element               | Co oznacza i dlaczego ważne                                 |
| --------------------- | ----------------------------------------------------------- |
| Metoda (GET/POST/PUT) | Różne operacje dane vs odczyt                               |
| URL/ścieżka           | Punkt wejścia do zasobów aplikacji                          |
| Host                  | Virtual host – różne aplikacje mogą działać na tej samej IP |
| Nagłówki              | Można je modyfikować, atakować, przekazywać                 |
| Cookies               | Sesje, autoryzacja — często cel ataków                      |
| Body                  | Dane POST — często parametr ataku                           |

### **Gdzie realnie zaczynają się podatności**

#### &#x20;Nagłówki

* Serwery/proxy mogą inaczej interpretować te same wartości — to prowadzi do _HTTP request smuggling_.
* Złe parsowanie „**Content-Length” vs „Transfer-Encoding”** = domena poważnych błędów.

#### Ciasteczka

* Mogą ujawniać **sesje** lub być podatne na XSS/CSRF.
* Warto przeanalizować ich **flagi**: `Secure`, `HttpOnly`, `SameSite`.

#### Proxy / Cache

* Proxy może modyfikować request lub response — różne zachowanie na froncie i backendzie = podatności takich jak smuggling.
* Cache może zwrócić stare lub niewłaściwe dane jeśli źle skonfigurowany.

#### Caching

* Nieprawidłowe reguły cache mogą ujawniać prywatne dane lub dopuszczać „cache poisoning”.

#### Dane wejściowe użytkownika

Parametry GET/POST — nienormalizowane dane mogą być wejściem ataku XSS, SQLi, header injection.

**Ustawienia Burp-a**

* Uruchom Burpa → **Proxy → Intercept**
*   Ustaw w przeglądarce (lub w narzędziach przeglądarki) proxy:

    ```
    Host: 127.0.0.1
    Port: 8080
    ```

## HTTP request smuggling

[link](https://portswigger.net/web-security/request-smuggling) -> [lab1](https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te)

Lab pokazuje **klasyczny HTTP Request Smuggling typu CL.TE**, czyli:

> **Frontend ufa nagłówkowi `Content-Length`, a backend ufa `Transfer-Encoding: chunked`**

To prowadzi do **rozjechania się granic requestu** pomiędzy dwoma serwerami.

#### Nagłówki HTTP/1.1

* `Content-Length` → mówi **ile bajtów ma body**
* `Transfer-Encoding: chunked` → body jest dzielone na **chunki**, koniec oznacza `0\r\n\r\n`

**RFC mówi jasno**:

> Jeśli występuje `Transfer-Encoding`, **Content-Length powinien być ignorowany**

Ale… **nie wszystkie implementacje robią to poprawnie**.

**CL.TE = Content-Length / Transfer-Encoding**

* Frontend: **czyta body wg Content-Length**
* Backend: **czyta body wg chunków**

To powoduje, że:

* frontend kończy request wcześniej
* backend czyta **więcej danych**, w tym **kolejne żądanie**

## Payload w labie

W labie wysyłasz request w tym stylu (uproszczony):

```http
POST / HTTP/1.1
Host: vulnerable-website
Content-Length: 44
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable-website
```

***

### Co widzi FRONTEND (CL = 44)

Frontend:

* Czyta dokładnie **44 bajty**
*   Widzi:

    ```
    0\r\n\r\n
    ```
* Myśli: **request zakończony**

Reszta zostaje w buforze

***

### Co widzi BACKEND (TE = chunked)

Backend:

* Widzi `0` → koniec chunków
* Następne bajty interpretuje jako **NOWY REQUEST**

&#x20;`GET /admin HTTP/1.1`

**Smuggling udany.**

## Dlaczego to jest groźne (realny impact)

HTTP Request Smuggling może prowadzić do:

* bypassu autoryzacji
* cache poisoning
* session hijacking
* request routing attacks
* XSS / account takeover (pośrednio)

CL.TE vulnerability polega na tym, że frontend i backend inaczej interpretują granice requestu, co pozwala „przemycić” ukryte żądanie HTTP do backendu.



## Jak PRZECIWDZIAŁAĆ

### ZŁOTA ZASADA

> **Frontend i backend MUSZĄ parsować HTTP identycznie**

***

### A. Najskuteczniejsze środki

#### 1. Usuwaj `Content-Length`, gdy jest `Transfer-Encoding`

Na **reverse proxy / load balancerze**

RFC 9112:

> `Transfer-Encoding` overrides `Content-Length`

***

#### 2. Normalizacja requestów

* tylko jeden:
  * `Content-Length`
  * **albo**
  * `Transfer-Encoding`
* nie oba naraz

(OWASP ASVS 4.0 – V5)

***

#### 3. Używaj HTTP/2 między frontend ↔ backend

HTTP/2:

* **nie używa** `Content-Length` w ten sposób
* eliminuje całą klasę attacków

https://portswigger.net/web-security/request-smuggling/http2

***

#### 4. Aktualizuj serwery i proxy

Znane podatności:

* nginx < określonych wersji
* Apache mod\_proxy
* HAProxy (starsze)

[https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn](https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn)

***

### B. WAF ≠ rozwiązanie&#x20;

* WAF **często da się ominąć**
* działa **po frontendzie**
* nie rozwiązuje desync

***

### C. Checklist (do audytu)

✔ jeden parser HTTP\
✔ brak CL + TE razem\
✔ aktualny proxy\
✔ H2 wewnętrznie\
✔ testy smugglingu w CI
