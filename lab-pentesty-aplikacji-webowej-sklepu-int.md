# LAB: Pentesty aplikacji webowej (sklepu int)

_w trakcie..._

***

## Lab Pentestów Webowych z uwzględnieniem OWASP Top 10

***

#### 1. Przygotowanie środowiska

* Dostęp do testowej wersji aplikacji (nie produkcyjnej!)
* Narzędzia:
  * Burp Suite Community/Pro lub OWASP ZAP (proxy i skaner)
  * SQLMap (SQL injection)
  * Nmap (skan portów)
  * Nikto (skan serwera)
  * Przeglądarka z DevTools
  * Inne narzędzia według potrzeb (np. Metasploit, Dirbuster)

***

#### 2. Reconnaissance i analiza architektury (A01:2021 — Broken Access Control)

* Przegląd dostępnych URL, endpointów API, paneli admina
* Sprawdzenie pliku robots.txt, sitemap.xml
* Analiza metod uwierzytelniania i uprawnień
* Testy, czy użytkownik może uzyskać dostęp do zasobów zarezerwowanych dla innych (np. normalny user do panelu admina)

***

#### 3. Testy Injection (A03:2021 — Injection)

* Testowanie podatności na SQL Injection, Command Injection, LDAP Injection
* Próby wstrzyknięcia typowych payloadów do formularzy, parametrów URL:
  * `' OR 1=1--`
  * `; DROP TABLE users;`
*   Automatyczne testy za pomocą SQLMap:

    ```
    sqlmap -u "https://twojsklep.pl/product?id=123" --batch --dbs
    ```

***

#### 4. Testy bezpieczeństwa uwierzytelniania (A07:2021 — Identification and Authentication Failures)

* Próby brute-force na logowanie
* Sprawdzenie, czy hasła mają minimalne wymagania (długość, złożoność)
* Test sesji: czy tokeny sesji są unikalne, wygasają po wylogowaniu?
* Sprawdzenie mechanizmów odzyskiwania hasła (nie powinny ujawniać zbyt wielu informacji)

***

#### 5. Testy Cross-Site Scripting (A07:2021 — Cross-Site Scripting)

* Wprowadzanie skryptów JavaScript do pól tekstowych, komentarzy itp.
* Sprawdzenie, czy aplikacja poprawnie koduje dane wyjściowe (escape)
* Testowanie różnych typów XSS: refleksyjny, przechowywany, DOM-based

***

#### 6. Testy konfiguracji bezpieczeństwa (A05:2021 — Security Misconfiguration)

* Sprawdzenie, czy wymuszany jest HTTPS
* Analiza nagłówków bezpieczeństwa HTTP:
  * Content-Security-Policy
  * X-Frame-Options
  * Strict-Transport-Security (HSTS)
  * X-Content-Type-Options
* Sprawdzenie wersji serwera i frameworków (czy są aktualne)
* Skanowanie narzędziem Nikto

***

#### 7. Testy podatności deserializacji (A08:2021 — Insecure Deserialization)

* Jeśli aplikacja używa serializacji obiektów (np. JSON, XML) — testy na wstrzykiwanie złośliwych danych
* Próby przekazania niespodziewanych danych, które mogą spowodować wykonanie kodu lub błędy

***

#### 8. Testy zarządzania sesją (A02:2021 — Cryptographic Failures i A07:2021 — Identification and Authentication Failures)

* Sprawdzenie, czy cookies mają flagi `HttpOnly` i `Secure`
* Testy na przechwycenie sesji (session hijacking)
* Sprawdzenie, czy tokeny sesyjne są odpowiednio losowe i długie

***

#### 9. Testy kontroli dostępu (A01:2021 — Broken Access Control)

* Próby dostępu do funkcji i zasobów bez odpowiednich uprawnień
* Testowanie poziomów dostępu (np. czy zwykły user może zmienić dane innych)

***

#### 10. Testy eksfiltracji danych i zarządzania danymi (A03:2021 — Injection i A04:2021 — Insecure Design)

* Sprawdzenie, czy wrażliwe dane są odpowiednio chronione (np. hasła hash’owane, dane szyfrowane)
* Testy na wycieki danych w odpowiedziach serwera (np. stacktrace, błędy)
* Analiza, czy aplikacja nie ujawnia zbyt wielu informacji (np. w błędach)

***

#### 11. Raportowanie

* Dokumentacja znalezionych podatności z opisem ryzyka i sposobem naprawy
* Priorytetyzacja problemów według ich krytyczności
* Rekomendacje dla zespołu deweloperskiego

***

#### 12. Dalsze kroki

* Retesty po wdrożeniu poprawek
* Automatyczne monitorowanie bezpieczeństwa (np. CI/CD z testami bezpieczeństwa)
* Edukacja zespołu i regularne przeglądy bezpieczeństwa

***

**Materiały pomocnicze:**

* OWASP Top 10 2021: [https://owasp.org/Top10/](https://owasp.org/Top10/)
* OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)
* Narzędzia OWASP: [https://owasp.org/www-project-top-ten/tools/](https://owasp.org/www-project-top-ten/tools/)

***

Jasne, Anno! Poniżej przygotowałem dla Ciebie kilka **praktycznych przykładów testów bezpieczeństwa** dla wybranych podatności z OWASP Top 10. Do każdego testu opiszę, jak go wykonać krok po kroku — możesz to zrobić samodzielnie albo wykorzystać jako bazę do dalszych działań.

***

## Przykładowe testy bezpieczeństwa dla webowej aplikacji

***

### 1. Test na SQL Injection (A03:2021 — Injection)

**Cel:** Sprawdzenie, czy aplikacja jest podatna na wstrzyknięcie SQL.

**Jak testować:**

* Znajdź pole formularza lub parametr URL, który przekazuje dane do bazy (np. produkt?id=123)
* Wprowadź w to pole coś takiego: `' OR '1'='1`
* Jeśli po wysłaniu aplikacja pokazuje wszystkie rekordy, błędy bazy danych lub inne nienaturalne zachowania, to znak podatności

**Przykład:**\
W przeglądarce wpisz URL:

```
https://twojsklep.pl/product?id=1' OR '1'='1
```

Albo w polu wyszukiwania wpisz:

```
' OR '1'='1
```

**Automatyzacja z SQLMap:**

```bash
sqlmap -u "https://twojsklep.pl/product?id=1" --batch --dbs
```

***

### 2. Test na Cross-Site Scripting (XSS) (A07:2021)

**Cel:** Sprawdzenie, czy aplikacja poprawnie zabezpiecza się przed wstrzykiwaniem skryptów.

**Jak testować:**

* Wpisz w pole tekstowe lub komentarz payload:

```html
<script>alert('XSS')</script>
```

* Jeśli po wysłaniu i odświeżeniu strony pojawi się alert lub skrypt wykona się, aplikacja jest podatna.

**Warianty:**

* Refleksyjny XSS: payload pojawia się od razu po wysłaniu formularza (np. w URL).
* Przechowywany XSS: payload jest zapisywany i wyświetlany innym użytkownikom.

***

### 3. Test na Broken Access Control (A01:2021)

**Cel:** Sprawdzenie, czy można uzyskać dostęp do zasobów bez odpowiednich uprawnień.

**Jak testować:**

* Zaloguj się jako zwykły użytkownik.
* Spróbuj wejść na adres panelu administratora (np. `/admin`, `/dashboard`).
* Sprawdź, czy strona przekierowuje lub blokuje dostęp.
* Spróbuj wykonać akcje zarezerwowane dla admina (np. zmiana danych innych użytkowników).

***

### 4. Test na Security Misconfiguration (A05:2021)

**Cel:** Sprawdzenie, czy serwer i aplikacja są poprawnie skonfigurowane.

**Jak testować:**

* Sprawdź, czy strona wymusza HTTPS (czy przekierowuje z HTTP na HTTPS).
* Użyj narzędzia Nikto, aby przeskanować serwer:

```bash
nikto -h twojsklep.pl
```

* Sprawdź nagłówki HTTP (np. w DevTools, zakładka Network):
  * Czy jest `Content-Security-Policy`?
  * Czy jest `X-Frame-Options: DENY` lub `SAMEORIGIN`?
  * Czy jest `Strict-Transport-Security`?

***

### 5. Test na uwierzytelnianie i sesje (A02:2021)

**Cel:** Sprawdzenie, czy mechanizmy logowania i sesji są bezpieczne.

**Jak testować:**

* Sprawdź, czy można ustawić słabe hasło (np. „12345”).
* Spróbuj wielokrotnie wpisać błędne hasła i zobacz, czy konto zostaje zablokowane (ochrona przed brute-force).
* Sprawdź, czy po wylogowaniu sesja jest niszczona (np. czy nie można wrócić do panelu po kliknięciu „wstecz” w przeglądarce).
* Sprawdź, czy ciasteczka sesyjne mają flagi `HttpOnly` i `Secure` (w DevTools → Application → Cookies).

***





***

## Gotowe przykłady testów i komendy

***

### 1. SQL Injection — test z SQLMap

Jeśli masz dostęp do terminala, użyj SQLMap do automatycznego sprawdzenia podatności SQLi:

```bash
sqlmap -u "https://twojsklep.pl/product?id=1" --batch --dbs
```

* `-u` — URL z parametrem podejrzanym o SQLi
* `--batch` — automatyczne potwierdzanie pytań (tryb bez interakcji)
* `--dbs` — wypisuje bazy danych, jeśli podatność istnieje

***

### 2. XSS — ręczny test w przeglądarce

W formularzu, np. polu wyszukiwania lub komentarza, wpisz:

```html
<script>alert('XSS')</script>
```

* Zatwierdź i obserwuj, czy wyskakuje okienko alertu.
* Jeśli tak, aplikacja jest podatna na XSS.

***

### 3. Burp Suite — proxy do testów manualnych

#### Ustawienie proxy:

1. Uruchom Burp Suite.
2. W zakładce **Proxy → Options** sprawdź port proxy (domyślnie 127.0.0.1:8080).
3. W przeglądarce ustaw proxy na 127.0.0.1 i port 8080 (w ustawieniach sieci).
4. Włącz przechwytywanie w Burp Suite (Proxy → Intercept → On).

#### Test manualny:

* Przeglądaj stronę, wypełniaj formularze — Burp przechwyci każde zapytanie HTTP.
* W zakładce **Intercept** możesz modyfikować zapytania, np. podmienić parametry na payloady:
  * SQLi: `' OR '1'='1`
  * XSS: `<script>alert('XSS')</script>`
* Zatwierdź i obserwuj odpowiedzi serwera.

***

### 4. Sprawdzanie nagłówków bezpieczeństwa w przeglądarce

1. Otwórz DevTools (F12) → zakładka **Network**.
2. Odśwież stronę i kliknij na główny request (np. `https://twojsklep.pl`).
3. Sprawdź zakładkę **Headers** → sekcja **Response Headers**.
4. Szukaj nagłówków:
   * `Content-Security-Policy`
   * `X-Frame-Options`
   * `Strict-Transport-Security`
   * `X-Content-Type-Options`

***

### 5. Sprawdzanie ciasteczek sesyjnych

1. W DevTools → zakładka **Application** → **Cookies** → wybierz domenę sklepu.
2. Sprawdź flagi przy ciasteczkach:
   * `Secure` — ciasteczko przesyłane tylko po HTTPS
   * `HttpOnly` — ciasteczko niedostępne dla JavaScript (chroni przed XSS)

***



***

## Rozbudowa zestawu testów i skrypty do Burp Suite

***

### 1. Test na Broken Access Control (A01:2021)

#### Test ręczny:

* Zaloguj się jako zwykły użytkownik.
* W Burp Suite w zakładce **Proxy → HTTP history** znajdź zapytanie do zasobu wymagającego uprawnień (np. `/admin/deleteUser?id=123`).
* Kliknij prawym i wybierz **Send to Intruder**.

#### Skrypt do Intrudera:

* Ustaw **Payload positions** na parametr `id`.
* Wybierz listę wartości do testów — np. `1, 2, 3, 9999` (spróbuj różnych ID użytkowników).
* Uruchom atak i obserwuj, czy dostajesz odpowiedź, która powinna być zablokowana.

***

### 2. Test na Cross-Site Request Forgery (CSRF) (A08:2021 - Insecure Design)

#### Test ręczny:

* Sprawdź, czy formularze wykonujące zmiany stanu (np. zmiana hasła, dodanie produktu) mają tokeny CSRF w ukrytych polach lub nagłówkach.

#### Test w Burp Suite:

* W zakładce **Proxy** przechwyć zapytanie POST do np. zmiany hasła.
* Usuń lub zmodyfikuj token CSRF (jeśli jest) i wyślij zapytanie dalej.
* Jeśli serwer zaakceptuje takie zapytanie, aplikacja jest podatna.

***

### 3. Test na Insecure Deserialization (A08:2021)

* Jeśli aplikacja używa serializowanych danych (np. JSON lub XML w ciele żądań), spróbuj zmodyfikować wartości, np. zamienić `true` na `false`, albo wprowadzić nietypowe dane (np. ciągi znaków, które mogą wywołać błędy).
* W Burp Suite zmień wartości w ciele requesta i obserwuj odpowiedzi serwera.

***

### 4. Test na Security Misconfiguration (A05:2021)

#### Test automatyczny z Nikto:

```bash
nikto -h https://twojsklep.pl
```

* Sprawdź raport i zwróć uwagę na błędy konfiguracyjne, stare wersje oprogramowania, brak nagłówków bezpieczeństwa.

#### Test ręczny:

* Sprawdź, czy HTTP i HTTPS działają, a HTTP przekierowuje na HTTPS.
* W DevTools sprawdź, czy nagłówki bezpieczeństwa są obecne (CSP, HSTS itd.).

***

### 5. Przykładowy skrypt Burp Suite Intruder do testu SQL Injection w parametrze `id`

* W zakładce **Intruder → Positions** usuń wszystkie automatyczne zaznaczenia i zaznacz tylko parametr `id`.
* W zakładce **Payloads** wklej listę typowych payloadów SQL Injection, np.:

```
'
' OR '1'='1
' OR '1'='1' --
' OR '1'='1' /*
admin' --
admin' #
' OR 1=1--
' OR 1=1#
' OR 1=1/*
```

* Uruchom atak i obserwuj odpowiedzi, czy pojawiły się różnice w treści (np. większa liczba wyników, błędy SQL).

***

### 6. Przykład prostego skryptu do automatycznego testowania XSS w polu `search`

* W Burp Suite przechwyć zapytanie GET do np. `/search?q=apple`.
* Wyślij do Intrudera, zaznacz parametr `q`.
* W zakładce Payloads użyj listy payloadów XSS:

```
<script>alert(1)</script>
"><script>alert(1)</script>
'><img src=x onerror=alert(1)>
```

* Obserwuj odpowiedzi, szukaj pojawienia się tych payloadów lub alertów (jeśli testujesz ręcznie).

***

## Dodatkowe wskazówki

* Ustaw filtry w Burp Suite na unikalne odpowiedzi — by szybko wykrywać potencjalne problemy.
* Korzystaj z opcji **Comparer** do porównywania odpowiedzi serwera.
* Regularnie aktualizuj bazę payloadów i narzędzia.

***





## Jak sprawdzić błędy w konfiguracji MySQL, dostęp do pliku konfiguracyjnego i podatności API?

***

### 1. Sprawdzanie błędów w konfiguracji MySQL

#### a) Logowanie do MySQL i przegląd konfiguracji

* Zaloguj się do serwera MySQL (jeśli masz dostęp):

```bash
mysql -u root -p
```

* Sprawdź konfigurację (np. ustawienia bezpieczeństwa, uprawnienia użytkowników):

```sql
SHOW VARIABLES LIKE '%secure%';
SHOW GRANTS FOR 'someuser'@'localhost';
```

* Sprawdź, czy konto root nie jest dostępne zdalnie:

```sql
SELECT user, host FROM mysql.user WHERE user='root';
```

#### b) Testowanie podatności przez aplikację (np. blind SQL injection)

* Sprawdź, czy parametry przekazywane do bazy są odpowiednio zabezpieczone (np. za pomocą wcześniej opisanych testów SQLi).
* Sprawdź, czy błędy bazy danych nie są wyświetlane użytkownikowi (unikać ujawniania struktury bazy).

#### c) Audyt pliku my.cnf (konfiguracji MySQL)

* Sprawdź, czy plik konfiguracyjny `my.cnf` (lub `my.ini`) ma odpowiednie uprawnienia (np. 600), żeby nie był czytelny dla innych użytkowników.
* Zwróć uwagę na ustawienia, takie jak `skip-networking` (powinno być włączone, jeśli nie potrzebujesz zdalnego dostępu), `bind-address` (czy nasłuchuje tylko na localhost).

***

### 2. Sprawdzenie dostępu do pliku konfiguracyjnego aplikacji (np. config.php)

#### a) Test ręczny (np. przez HTTP)

* Spróbuj otworzyć plik konfiguracyjny przez przeglądarkę:

```
https://twojsklep.pl/config.php
```

* Jeśli plik się wyświetla, oznacza to poważną lukę (plik powinien być niedostępny z sieci).

#### b) Sprawdzenie uprawnień na serwerze

* Sprawdź, czy plik ma odpowiednie prawa (np. 600) i właściciela (zwykle użytkownik serwera WWW, np. www-data).
* Plik konfiguracyjny nie powinien być w publicznym katalogu (np. `/var/www/html/`), ale wyżej (np. `/var/www/`).

***

### 3. Sprawdzanie podatności API

#### a) Sprawdzenie uwierzytelniania i autoryzacji

* Czy każde API wymaga tokenu (np. JWT, OAuth)?
* Sprawdź, czy tokeny mają odpowiedni czas życia i są poprawnie weryfikowane.
* Sprawdź, czy nie da się wykonać akcji bez tokenu lub z tokenem innego użytkownika (Broken Access Control).

#### b) Testy na wstrzyknięcia (SQLi, XSS) w API

* Wysyłaj złośliwe dane w polach JSON lub parametrów URL.
* Obserwuj, czy API zwraca błędy, ujawnia strukturę bazy, albo wykonuje nieautoryzowane operacje.

#### c) Testy limitów i zabezpieczeń

* Sprawdź, czy API ma limity rate limiting (by chronić przed brute-force i DoS).
* Testuj czy API poprawnie filtruje i waliduje dane wejściowe.

***

Świetne pytanie, Anno! Automatyzacja pentestów to klucz do efektywnego i powtarzalnego sprawdzania bezpieczeństwa aplikacji, zwłaszcza gdy projekt rośnie. Podpowiem Ci, jak możesz to zrobić krok po kroku, jakie narzędzia warto użyć i jak zorganizować proces.

***

##

## Jak zautomatyzować pentesty webowej aplikacji?

***

### 1. Wybierz narzędzia do automatycznego skanowania

#### Popularne narzędzia:

* **OWASP ZAP** (open source, świetne do skanowania i automatycznych testów)
* **Burp Suite Professional** (posiada funkcje automatycznego skanowania i Intruder)
* **Nikto** (skaner serwera WWW pod kątem błędów konfiguracji)
* **SQLMap** (automatyczne testowanie SQL Injection)
* **Nessus, OpenVAS** (do ogólnych testów bezpieczeństwa)

***

### 2. Skryptowanie i orkiestracja testów

* **Automatyzacja uruchamiania skanów:**\
  Np. przygotuj skrypty bash/Python, które odpala skanery z odpowiednimi parametrami na Twojej aplikacji.
*   **Przykład prostego skryptu do uruchomienia SQLMap i zapisania raportu:**

    ```bash
    #!/bin/bash
    sqlmap -u "https://twojsklep.pl/product?id=1" --batch --dbs --output-dir=./reports/sqlmap_$(date +%F)
    ```
* **Harmonogram (cron job):**\
  Ustaw zadania, które będą uruchamiać testy np. codziennie lub co tydzień, aby regularnie sprawdzać aplikację.

***

### 3. CI/CD i pentesty

* Zintegruj skanery bezpieczeństwa z pipeline CI/CD (np. Jenkins, GitHub Actions):
  * Po każdej aktualizacji kodu uruchamiaj automatyczne testy bezpieczeństwa.
  * Jeśli pojawi się krytyczna luka, build może się nie powieść — wymusza to szybkie naprawy.

***

### 4. Parsowanie i analiza wyników

* Automatyczne narzędzia generują raporty (HTML, JSON, XML).
* Przygotuj skrypty lub użyj narzędzi do agregacji i analizy wyników.
* Możesz wykorzystać np. ELK Stack (Elasticsearch, Logstash, Kibana) do wizualizacji wyników.

***

### 5. Testy dynamiczne + fuzzing

* Używaj fuzzingu (np. Burp Suite Intruder, OWASP ZAP fuzzers) do automatycznego wysyłania dużej ilości różnych payloadów.
* Wykorzystuj narzędzia do dynamicznego testowania API, np. **Postman + Newman** z testami bezpieczeństwa.

***

### 6. Automatyczne testy bezpieczeństwa API

* Narzędzia takie jak **Postman**, **Rest-Assured**, czy **Karate** pozwalają pisać testy automatyczne (również z payloadami testującymi podatności).
* Możesz integrować te testy z pipeline CI/CD.

***

### 7. Przykładowy pipeline CI z OWASP ZAP i GitHub Actions

```yaml
name: Security Scan

on: [push]

jobs:
  zap_scan:
    runs-on: ubuntu-latest
    steps:
      - name: Run OWASP ZAP baseline scan
        uses: zaproxy/action-baseline@v0.5.0
        with:
          target: 'https://twojsklep.pl'
```

***

## Podsumowanie

* Automatyzuj podstawowe testy (SAST/DAST).
* Integruj z pipeline CI/CD, by łapać problemy wcześnie.
* Korzystaj z różnych narzędzi i technik (fuzzing, dynamiczne testy, analiza konfiguracji).
* Regularnie aktualizuj narzędzia i payloady.

***

